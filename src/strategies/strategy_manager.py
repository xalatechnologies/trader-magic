"""
Strategy Manager for handling multiple trading strategies.
"""

from typing import Dict, Any, List, Optional
import threading
import time
import json
from datetime import datetime

from src.utils import get_logger, TradeSignal, redis_client
from src.strategies.base_strategy import BaseStrategy, StrategyRegistry

logger = get_logger("strategy_manager")

class StrategyManager:
    """
    Manager for handling multiple trading strategies.
    Can run strategies simultaneously or in sequence.
    """
    
    def __init__(self):
        """Initialize the strategy manager"""
        self.active_strategies = {}  # name -> strategy instance
        self.strategy_enabled = {}   # name -> bool
        self.polling_interval = 60   # seconds
        self.running = False
        self.poll_thread = None
        
        # Initialize with all available strategies
        self._initialize_strategies()
        
    def _initialize_strategies(self):
        """Initialize all available strategies from the registry"""
        strategy_infos = StrategyRegistry.list_strategies()
        logger.info(f"Initializing {len(strategy_infos)} available strategies")
        
        for info in strategy_infos:
            strategy_class = info.get('class')
            if not strategy_class:
                continue
                
            # Get the strategy instance
            strategy = StrategyRegistry.get_strategy(strategy_class)
            if strategy:
                self.active_strategies[strategy_class] = strategy
                self.strategy_enabled[strategy_class] = True
                logger.info(f"Added strategy: {strategy.name}")
                
                # Store strategy info in Redis for the frontend to access
                strategy_info = {
                    "name": strategy.name,
                    "class": strategy_class,
                    "description": strategy.description,
                    "enabled": True
                }
                redis_key = f"strategy:{strategy_class}:info"
                redis_client.set_json(redis_key, strategy_info)
                
                # Also store the enabled status
                enabled_key = f"strategy:{strategy_class}:enabled"
                redis_client.client.set(enabled_key, "true")
                
        # Start Redis listener for strategy commands from frontend
        self._start_redis_listener()
    
    def enable_strategy(self, strategy_name: str, enabled: bool = True):
        """
        Enable or disable a specific strategy
        
        Args:
            strategy_name: Name of the strategy class
            enabled: True to enable, False to disable
        """
        if strategy_name in self.strategy_enabled:
            self.strategy_enabled[strategy_name] = enabled
            status = "enabled" if enabled else "disabled"
            logger.info(f"Strategy {strategy_name} {status}")
            
            # Store the enabled state in Redis
            redis_key = f"strategy:{strategy_name}:enabled"
            redis_client.client.set(redis_key, str(enabled).lower())
            
            # Also update the info object with the new enabled status
            info_key = f"strategy:{strategy_name}:info"
            strategy_info = redis_client.get_json(info_key)
            if strategy_info:
                strategy_info['enabled'] = enabled
                redis_client.set_json(info_key, strategy_info)
            
            return True
        else:
            logger.error(f"Strategy {strategy_name} not found")
            return False
    
    def is_strategy_enabled(self, strategy_name: str) -> bool:
        """Check if a strategy is enabled"""
        return self.strategy_enabled.get(strategy_name, False)
    
    def get_active_strategies(self) -> List[Dict[str, Any]]:
        """Get a list of all active strategies and their enabled status"""
        result = []
        for name, strategy in self.active_strategies.items():
            result.append({
                "name": strategy.name,
                "class": name,
                "description": strategy.description,
                "enabled": self.strategy_enabled.get(name, False)
            })
        return result
    
    def process_data(self, symbol: str, data: Dict[str, Any]) -> List[TradeSignal]:
        """
        Process data through all enabled strategies
        
        Args:
            symbol: Trading symbol
            data: Data for analysis
            
        Returns:
            List of trade signals generated by all enabled strategies
        """
        signals = []
        
        for name, strategy in self.active_strategies.items():
            # Skip disabled strategies
            if not self.strategy_enabled.get(name, False):
                logger.debug(f"Skipping disabled strategy: {name}")
                continue
                
            # Check if we have all required data for this strategy
            required_data = strategy.get_required_data()
            missing_data = [key for key in required_data if key not in data]
            
            if missing_data:
                logger.debug(f"Strategy {name} missing required data: {', '.join(missing_data)}")
                continue
                
            # Process data with this strategy
            try:
                signal = strategy.process_data(symbol, data)
                if signal:
                    # Add strategy info to the signal for tracking
                    signal.metadata = {"strategy": name, "strategy_name": strategy.name}
                    signals.append(signal)
                    logger.info(f"Strategy {name} generated {signal.decision.value} signal for {symbol}")
            except Exception as e:
                logger.error(f"Error processing data with strategy {name}: {e}")
                
        return signals
    
    def start_polling(self, interval: int = 60):
        """
        Start polling for data and generating signals in a background thread
        
        Args:
            interval: Polling interval in seconds
        """
        if self.running:
            logger.warning("Strategy manager is already running")
            return
            
        self.polling_interval = interval
        self.running = True
        self.poll_thread = threading.Thread(target=self._polling_loop, daemon=True)
        self.poll_thread.start()
        logger.info(f"Strategy manager started polling every {interval} seconds")
        
        # Store the running state in Redis
        redis_client.client.set('strategy_manager:running', 'true')
        redis_client.client.set('strategy_manager:interval', str(interval))
    
    def stop_polling(self):
        """Stop the polling thread"""
        self.running = False
        if self.poll_thread:
            self.poll_thread.join(timeout=5)
        logger.info("Strategy manager stopped polling")
        
        # Store the running state in Redis
        redis_client.client.set('strategy_manager:running', 'false')
    
    def _polling_loop(self):
        """Background polling loop to fetch data and generate signals"""
        while self.running:
            logger.debug("Strategy manager polling for data...")
            
            try:
                # Record last poll time in Redis for health monitoring
                redis_client.client.set('strategy_manager:last_poll', datetime.now().isoformat())
            except Exception as e:
                logger.error(f"Failed to update last poll timestamp: {e}")
            
            # Get all enabled symbols
            from src.config import config
            symbols = config.trading.symbols
            
            # Process each symbol
            for symbol in symbols:
                self._process_symbol(symbol)
                
            # Wait for next poll
            time.sleep(self.polling_interval)
            
    def _process_symbol(self, symbol: str):
        """
        Process a single symbol with all enabled strategies
        
        Args:
            symbol: Trading symbol to process
        """
        try:
            logger.info(f"Processing symbol: {symbol}")
            
            # Get all data for this symbol
            all_data = self._fetch_symbol_data(symbol)
            
            if not all_data:
                logger.warning(f"No data available for {symbol}")
                return
                
            logger.info(f"Fetched data for {symbol}: {list(all_data.keys())}")
            if 'rsi' in all_data:
                logger.info(f"RSI value for {symbol}: {all_data['rsi'].value}")
                
            # Process with all strategies
            logger.info(f"Processing {symbol} with {len(self.active_strategies)} strategies")
            signals = self.process_data(symbol, all_data)
            
            # If we got signals, handle them
            if signals:
                logger.info(f"Generated {len(signals)} signals for {symbol}")
                for signal in signals:
                    self._handle_signal(signal)
            else:
                logger.info(f"No signals generated for {symbol}")
        except Exception as e:
            logger.error(f"Error processing symbol {symbol}: {e}")
    
    def _fetch_symbol_data(self, symbol: str) -> Dict[str, Any]:
        """
        Fetch all data needed for strategies for a given symbol
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Dictionary with all available data for this symbol
        """
        all_data = {}
        
        # Get RSI data
        from src.data_retrieval import data_retrieval_service
        logger.info(f"Fetching RSI data for {symbol}")
        rsi_data = data_retrieval_service.get_latest_rsi(symbol)
        if rsi_data:
            all_data['rsi'] = rsi_data
            logger.info(f"Found RSI data for {symbol}: {rsi_data.value}")
        else:
            logger.warning(f"No RSI data found for {symbol}")
            
        # Get price data
        price_key = f"price:{symbol}"
        logger.info(f"Fetching price data for {symbol}")
        price_data = redis_client.get_json(price_key)
        if price_data:
            all_data['price'] = price_data
        
        # Get recent news for this symbol
        all_data['news_sentiment'] = self._get_latest_news_sentiment(symbol)
            
        return all_data
    
    def _get_latest_news_sentiment(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Get the latest news sentiment for a symbol
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Dictionary with news sentiment data or None
        """
        # Get all news items
        news_keys = redis_client.client.keys("news:*")
        if not news_keys:
            return None
            
        # Check each news item to see if it's relevant to this symbol
        formatted_symbol = symbol.split('/')[0] if '/' in symbol else symbol
        
        for key in news_keys:
            news_data = redis_client.get_json(key)
            if not news_data:
                continue
                
            # Check if this news item is about our symbol
            symbols = news_data.get('symbols', [])
            if formatted_symbol in symbols:
                # Get the sentiment score (from OpenAI processing)
                impact_score = news_data.get('impact_score')
                if impact_score is not None:
                    logger.info(f"Found news sentiment for {symbol}: {impact_score}")
                    return {
                        'score': impact_score,
                        'headline': news_data.get('headline', ''),
                        'timestamp': news_data.get('timestamp')
                    }
        
        return None
    
    def _handle_signal(self, signal: TradeSignal):
        """
        Handle a generated trade signal
        
        Args:
            signal: Trading signal to handle
        """
        # Get the strategy that generated this signal
        strategy_name = signal.metadata.get('strategy_name', 'Unknown') if hasattr(signal, 'metadata') else 'Unknown'
        
        # Store the signal in Redis
        redis_key = f"signal:{signal.symbol}"
        redis_client.set_json(redis_key, signal.dict(), ttl=3600)  # 1 hour TTL
        
        logger.info(f"Stored {signal.decision.value} signal for {signal.symbol} from strategy {strategy_name}")
        
        # Notify services through Redis
        redis_client.client.publish('trade_notifications', f"New trade signal for {signal.symbol}: {signal.decision.value}")

    def _start_redis_listener(self):
        """Start a Redis listener for strategy commands from the frontend"""
        try:
            # Create a separate thread for the Redis listener
            self.redis_thread = threading.Thread(target=self._redis_listener_loop, daemon=True)
            self.redis_thread.start()
            logger.info("Redis listener for strategy commands started")
        except Exception as e:
            logger.error(f"Error starting Redis listener: {e}")
    
    def _redis_listener_loop(self):
        """Background loop to listen for strategy commands from Redis"""
        try:
            # Subscribe to the strategy_updates channel
            pubsub = redis_client.client.pubsub()
            pubsub.subscribe('strategy_updates')
            logger.info("Subscribed to 'strategy_updates' Redis channel")
            
            # Listen for messages
            for message in pubsub.listen():
                try:
                    if message['type'] == 'message':
                        # Handle both string and bytes data types
                        data = message['data']
                        if isinstance(data, bytes):
                            data = data.decode('utf-8')
                        logger.info(f"Received Redis command: {data}")
                        
                        # Parse the JSON data
                        command = json.loads(data)
                        action = command.get('action')
                        
                        # Handle different commands
                        if action == 'enable_strategy':
                            strategy_name = command.get('strategy')
                            enabled = command.get('enabled', True)
                            if strategy_name:
                                self.enable_strategy(strategy_name, enabled)
                                logger.info(f"Strategy {strategy_name} {'enabled' if enabled else 'disabled'} via Redis")
                                
                        elif action == 'start_polling':
                            interval = command.get('interval', 60)
                            self.start_polling(interval=interval)
                            logger.info(f"Strategy manager polling started with interval {interval}s via Redis")
                            
                        elif action == 'stop_polling':
                            self.stop_polling()
                            logger.info("Strategy manager polling stopped via Redis")
                            
                        elif action == 'poll_now':
                            logger.info("Manual poll triggered via Redis")
                            # Call the polling loop method directly once
                            self._process_all_symbols()
                            
                        else:
                            logger.warning(f"Unknown Redis command action: {action}")
                except Exception as e:
                    logger.error(f"Error processing Redis command: {e}")
        except Exception as e:
            logger.error(f"Error in Redis listener loop: {e}")
            
    def handle_signal(self, signal, frame):
        """Handle termination signals"""
        logger.info("Received termination signal, shutting down strategy manager...")
        self.stop_polling()
        
        # Stop the Redis listener too
        if hasattr(self, 'redis_thread') and self.redis_thread.is_alive():
            # Can't really stop a thread, but we can notify in logs
            logger.info("Redis listener thread will terminate when process exits")

    def _process_all_symbols(self):
        """Process all configured symbols once"""
        logger.info("Processing all symbols...")
        try:
            # Get all enabled symbols
            from src.config import config
            symbols = config.trading.symbols
            
            # Process each symbol
            for symbol in symbols:
                self._process_symbol(symbol)
                
            logger.info("Finished processing all symbols")
        except Exception as e:
            logger.error(f"Error processing symbols: {e}")


# Singleton instance
strategy_manager = StrategyManager() 